var documenterSearchIndex = {"docs":
[{"location":"library/#API","page":"Library","title":"API","text":"","category":"section"},{"location":"library/#Linear-systems","page":"Library","title":"Linear systems","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"rfldiv\n\nequilibrators\n\ncondInfest","category":"page"},{"location":"library/#IterativeRefinement.rfldiv","page":"Library","title":"IterativeRefinement.rfldiv","text":"rfldiv(A,b,f=lu; kwargs...) -> x,bnorm,bcomp,flags\n\nCompute an accurate solution to a linear system A x = b using extra-precise iterative refinement, with error bounds.\n\nReturns solution x, a normwise relative forward error estimate bnorm, and maximum componentwise relative error estimate bcomp. Specifically,  bnorm is an estimate of  xtrue - x  x (max norms). If the problem is so ill-conditioned that a good solution is unrealizable, bnorm and bcomp are set to unity (unless expert). flags contains convergence diagnostics potentially interesting to specialists.\n\nArguments\n\nA: a matrix,\nb: a vector with the same eltype,\nf: a factorization function such as lu.\n\nKeywords\n\nDT: higher-precision type for refinement; defaults to widen(eltype(A))\nverbosity: 0(default): quiet, 1: report on iterations, 2: details.\nequilibrate::Bool: whether the function should equilibrate A (default true).\nmaxiter: default 20.\ntol: relative tolerance for convergence, in units of eps(T).\nexpert::Bool: whether to return questionable bounds in extreme cases.\nκ: the (max-norm) condition of A (see below).\nF: a factorization of A (see below).\n\nIf A has already been equilibrated, and a Factorization object F and condition estimate κ have already been computed, they may be provided as keyword arguments; no check for consistency is done here.\n\nUses the algorithm of Demmel et al. ACM TOMS, 32, 325 (2006).\n\n\n\n\n\n","category":"function"},{"location":"library/#IterativeRefinement.equilibrators","page":"Library","title":"IterativeRefinement.equilibrators","text":"equilibrators(A) -> R,C\n\ncompute row- and column-wise scaling vectors R,C for a matrix A such that the absolute value of the largest element in any row or column of Diagonal(R)*A*Diagonal(C) is close to unity. Designed to reduce the condition number of the working matrix.\n\n\n\n\n\n","category":"function"},{"location":"library/#IterativeRefinement.condInfest","page":"Library","title":"IterativeRefinement.condInfest","text":"condInfest(A,F,anorm)\n\ncomputes an approximation to the condition of matrix A in the infinity-norm, using factorization F and the precomputed infinity norm anorm of A.\n\n\n\n\n\n","category":"function"},{"location":"library/#Eigensystems","page":"Library","title":"Eigensystems","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"rfeigen","category":"page"},{"location":"library/#IterativeRefinement.rfeigen","page":"Library","title":"IterativeRefinement.rfeigen","text":"rfeigen(A,x,λ,DT) => λnew, xnew, status\n\nImprove the precision of a computed eigenpair (x,λ) for matrix A via multi-precision iterative refinement, using more-precise real type DT.\n\nThe higher precision DT is only used for residual computation (i.e. matrix-vector products), so this can be much faster than a full eigensystem solution with precise eltype.  This method works on a single eigenpair, and can fail spectacularly if there is another eigenvalue nearby.\n\n\n\n\n\nrfeigen(A,λ,DT) => λnew, xnew, status\n\nLike rfeigen(A,x,λ,DT), but initialize x via one step of inverse iteration.\n\n\n\n\n\nrfeigen(A, S::Schur, idxλ, DT, maxiter=5) -> vals, vecs, status\n\nImproves the precision of a cluster of eigenvalues of square matrix A via multi-precision iterative refinement, using more-precise real type DT, using a pre-computed Schur decomposition S. Returns improved estimates of eigenvalues and vectors generating the corresponding invariant subspace.\n\nThis method works on the set of eigenvalues in S.values indexed by idxλ. It is designed to handle (nearly) defective cases, but will fail if the matrix is extremely non-normal or the initial estimates are poor.\n\nIf S is a quasi-triangular \"real Schur\", it will be converted to a complex upper-triangular Schur decomposition. S may be a partial decomposition (i.e. fewer than size(A,1) vectors).\n\n\n\n\n\n","category":"function"},{"location":"#IterativeRefinement","page":"Overview","title":"IterativeRefinement","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package is an implementation of multi-precision iterative refinement for certain dense-matrix linear algebra problems.","category":"page"},{"location":"#Background","page":"Overview","title":"Background","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The purpose of iterative refinement (IR) is to improve the accuracy of a solution.  If x is the exact solution of A*x=b, a simple solve of the form y = A \\ b will have a relative forward error (norm(y-x)/norm(x)) of approximately ϵ * O(n) * cond(A) where ϵ is the unit roundoff error in the standard precision. Iterative refinement with higher precision residuals can reduce this to  ϵ * O(n), as long as the matrix A is not very badly conditioned relative to ϵ.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Why not do everything in high precision? The factorization step is typically very expensive (O(n^3)) in high precision, whereas the residual computation is relatively cheap (O(n^2)). Furthermore, IR schemes often provide useful error bounds.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For typical use, one would have a basic working precision of Float64 (ϵ = 2.2e-16), so that fast LAPACK/BLAS routines dominate the runtime. rfldiv will then (by default) use BigFloat for residuals. One might alternatively use Double64 from DoubleFloats.jl or Float128 from Quadmath.jl","category":"page"},{"location":"#Linear-systems","page":"Overview","title":"Linear systems","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package provides a function rfldiv, which handles linear matrix-vector problems of the form","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A x = b.","category":"page"},{"location":"#Basic-Usage","page":"Overview","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"julia> using LinearAlgebra, IterativeRefinement\njulia> x, bnorm, bcomp = rfldiv(A,b)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This provides an accurate solution vector x and estimated bounds on norm-wise and component-wise relative error. By default LU decomposition is used.","category":"page"},{"location":"#Advanced-Usage","page":"Overview","title":"Advanced Usage","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"See the function docstring for details.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If one has several right-hand-sides, one can equilibrate and factor A in advance; see the tests for an example.","category":"page"},{"location":"#Reference","page":"Overview","title":"Reference","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"J.Demmel et al., \"Error bounds from extra precise iterative refinement,\" LAPACK Working Note Nr. 165 (2005), also published as ACM TOMS, 32, 325 (2006).  The work described therein eventually turned into a collection of subroutines included in some versions of LAPACK.  This implementation is based on the paper; minor modifications were introduced based on experimentation. To be precise, this package implements Algorithm 3.","category":"page"},{"location":"#Eigensystems","page":"Overview","title":"Eigensystems","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Additional methods (rfeigen) are provided for improving estimates of eigenvalue/subspace pairs of the form","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A X = X λ.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For a simple eigenvalue, X is the corresponding eigenvector, and the user provides coarse estimates of both. In the case of multiple or defective eigenvalues, columns of X are generators for the corresponding invariant subspace, and the user provides a Schur decomposition with a list of indices for the cluster of interest.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Problem-specific error bound estimates are not yet provided for eigensystems.","category":"page"},{"location":"#Basic-Usage-2","page":"Overview","title":"Basic Usage","text":"","category":"section"},{"location":"#isolated-eigenvalue","page":"Overview","title":"isolated eigenvalue","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"julia> using LinearAlgebra, IterativeRefinement, Quadmath\njulia> E = eigen(A)\njulia> j = your_index_selection()\njulia> λrefined, xrefined = rfeigen(A, E.vectors[:,j], E.values[j], Float128)","category":"page"},{"location":"#eigenvalue-cluster","page":"Overview","title":"eigenvalue cluster","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"julia> using LinearAlgebra, IterativeRefinement, Quadmath\njulia> S = schur(A)\njulia> S = LinearAlgebra.Schur{ComplexF64}(S) # if eltype of A is real\njulia> idx = findall(abs.(S.values .- target) .< 0.1)\njulia> λrefined, Vrefined = rfeigen(A, S, idx, Float128)","category":"page"},{"location":"#Reference-2","page":"Overview","title":"Reference","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"J.J.Dongarra, C.B.Moler, and J.H.Wilkinson, \"Improving the accuracy of computed eigenvalues and eigenvectors,\" SIAM J. Numer. Anal. 20, 23-45 (1983).","category":"page"}]
}
